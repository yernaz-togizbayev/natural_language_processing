# -*- coding: utf-8 -*-
"""Exercise_Sheet_4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q1uPICd8sEJLCho_Zb7fQ-s43y9Igu0T

# Natural Language Processing

## Exercise Sheet 4
"""

#imports for all exercises
import pprint
import nltk
import timeit

from collections import Counter
from nltk.corpus import gutenberg
from nltk.corpus import wordnet as wn
from nltk.probability import FreqDist
from functools import lru_cache

nltk.download('gutenberg')
nltk.download('wordnet')
nltk.download('omw-1.4')

"""### Exercise 1

Write a program to initialize a two-dimensional array of sets called `word_vowels` and process a list of words, adding each word to `word_vowels[l][v]` where $l$ is the length of the word and $v$ is the number of vowels it contains. Test your program with a 10x10-array and the list `['Alice', 'hat', 'heute', 'ihren', 'freien', 'Tag']`.
"""

# Helper function to count vowels
def count_vowels(word):
    vowels = "aeiou"
    return sum(1 for letter in word if letter in vowels)

# Helper function to process a list of words
def process_words(words, word_vowels):
  for word in words:
    l = len(word)
    v = count_vowels(word.lower())
    if l < 10 and v < 10:
        word_vowels[l][v].add(word)

# Test list
words = ['Alice', 'hat', 'heute', 'ihren', 'freien', 'Tag']

# Initialize a 10x10 array of sets
word_vowels = [[set() for _ in range(10)] for _ in range(10)]

# Process the list of words
process_words(words, word_vowels)

# Print non-empty entries
for l in range(10):
    for v in range(10):
        if word_vowels[l][v]:
            print(f"Length: {l}, Vowels: {v}: {word_vowels[l][v]}")

"""### Exercise 2

Write a program that prints all words that only appear in the last 10\% of a text. Test your code with the file `'shakespeare-macbeth.txt'` from the Gutenberg Corpus.

"""

# Load and clean the text
macbeth_words = [word.lower() for word in gutenberg.words('shakespeare-macbeth.txt') if word.isalpha()]

# Calculate the index for the last 10%
text_length = len(macbeth_words)
last_10_percent_index = int(text_length * 0.9)

# Split the text into the last 10% and the rest of the text
last_10_percent_words = macbeth_words[last_10_percent_index:]
rest_of_text_words = macbeth_words[:last_10_percent_index]

# Count word frequencies in both parts using FreqDist
count_last_10_percent_word = FreqDist(last_10_percent_words)
count_rest_of_text_word = FreqDist(rest_of_text_words)

# Find words that only appear in the last 10%
last_10_percent_unique_words = [word for word in count_last_10_percent_word if word not in count_rest_of_text_word]

# Print results
print(f"Total number of words: {text_length}")
print(f"Number of unique words that appears only in last 10%: {len(last_10_percent_unique_words)}")
print("Words that only appear in the last 10% of the text:")
for word in sorted(last_10_percent_unique_words):
    print(word)

"""### Exercise 3

Write a program that takes a sentence expressed as a single string, splits it and counts up the words. Get it to print out each word and the word's frequency, one per line, in alphabetical order. Test it with the sentence: `'das ist heute wieder einmal wirklich ein sehr schöner tag das kann ich dir wieder einmal sagen'`.

"""

# Test sentence
sentence = 'das ist heute wieder einmal wirklich ein sehr schöner tag das kann ich dir wieder einmal sagen'

# Split the sentence into words
words = sentence.split()

# Count up the words
word_counts = Counter(words)

# Print words and their frequencies in alphabetical order
for word, counter in sorted(word_counts.items()):
    print(f"{word}: {counter}")

"""### Exercise 4

Write a function `sort_dist(candidates, target)`. The `candidates` are a list of strings representing WordNet synset names, and `target` a synset name string. The function shall sort the `candidates` for proximity to the `target` synset using `shortest_path_distance()`.

Test your function with `candidates=['minke_whale.n.01','orca.n.01','novel.n.01', 'tortoise.n.01']` and `target='right_whale.n.01'`.
"""

def sort_dist(candidates, target):
  target_synset = wn.synset(target)
  candidate_distance_pair = [(candidate, wn.synset(candidate).shortest_path_distance(target_synset)) for candidate in candidates]
  candidate_distance_pair.sort(key=lambda x: x[1])
  return candidate_distance_pair

# Test data
candidates = ['minke_whale.n.01','orca.n.01','novel.n.01', 'tortoise.n.01']
target = 'right_whale.n.01'

sorted_candidates = sort_dist(candidates, target)

print(f"Candidates sorted by distance to '{target}':")
for candidate, distance in sorted_candidates:
    print(f"{candidate}: distance = {distance}")

"""### Exercise 5

Write a recursive function `lookup(trie, key)` that looks up a `key` in a `trie`, and returns the value it finds. The function should cover the following cases:

a) it should return a corresponding message if the key is not included in the trie;  
b) it should return a message if the key is not unique, i.e. if there are several words for this prefix;  
c) if a word is uniquely determined by the key prefix it should be returned as result.

Try your function for the following trie and test cases:
"""

def insert(trie, key, value):
    if key:
        first, rest = key[0], key[1:]
        if first not in trie:
            trie[first] = {}
        insert(trie[first], rest, value)
    else:
        trie['value'] = value

trie = {}
insert(trie, 'chat', 'cat')
insert(trie, 'chien', 'dog')
insert(trie, 'chair', 'flesh')
insert(trie, 'chic', 'stylish')
insert(trie, 'cheval','horse')
trie = dict(trie)
pprint.pprint(trie, width=40)

def lookup(trie, key):
  if key:
      first, rest = key[0], key[1:]
      if first not in trie:
          return f"Key not found"
      return lookup(trie[first], rest)
  else:
      if 'value' in trie:
        return trie['value'] if len(trie) == 1 else "Key is not unique"

      if trie:
        return lookup(trie[next(iter(trie))], "") if len(trie) == 1 else "Next prefix exists, but key is not unique"
      return f"Key {key} not found"

print(lookup(trie, 'chat'))
print(lookup(trie, 'cha'))
print(lookup(trie, 'souris'))
print(lookup(trie, 'cheval'))
print(lookup(trie, 'che'))
print(lookup(trie, 'chev'))

"""### Exercise 6

Write a recursive function `pp_trie` that pretty prints a trie in alphabetically sorted order by replacing common prefixes with `'-'` characters.
Test your implementation with the following example data:
"""

trie = {}
insert(trie, 'chat', 'cat')
insert(trie, 'souris', 'mouse')
insert(trie, 'chien', 'dog')
insert(trie, 'chair', 'flesh')
insert(trie, 'chic', 'stylish')
insert(trie, 'cheval','horse')
trie = dict(trie)
pprint.pprint(trie, width=40)

def pp_trie(trie, prefix='', previous=['']):
    if 'value' in trie:
        prev = previous[0]
        i = 0
        for a, b in zip(prev, prefix):
            if a == b:
              i += 1
            else:
              break
        shown = prefix if i == 0 else '-' * i + prefix[i:]
        print(f"{shown}: {trie['value']}")
        previous[0] = prefix  # remember current word as previous

    # Recurse in alphabetical order
    for char in sorted(key for key in trie if key != 'value'):
        pp_trie(trie[char], prefix + char, previous)

#pp_trie(trie)

"""chair: flesh
    ---t: cat
    --eval: horse
    --ic: stylish
    ---en: dog
    souris: mouse

### Exercise 7

The *Catalan numbers* arise in many applications of combinatorial mathematics, including the counting of parse trees. The series can be defined as follows: $C_0 = 1$, and $C_{n+1} = \sum_{i=0}^{n}C_iC_{n-i}$ for $n\geq{0}$.

Write:

a) a recursive function `cn(n)` to compute the $n$th Catalan number $C_{n}$,  
b) a corresponding function `cn2(n)` that uses dynamic programming by storing calculated solutions in a lookup table,  
c) a function `cn3(n)`, which is identical to `cn(n)` but uses a `memoize` decorator.

Test your functions first by calculating the Catalan numbers $C_0\dots C_{16}$ and then by using the `timeit` module:
"""

def cn(n):
    if n == 0:
        return 1
    else:
        result = 0
        for i in range(n):
            result += cn(i) * cn(n - 1 - i)
        return result
def cn2(n, lookup=None):
    if lookup is None:
        lookup = [0] * (n + 1)
        lookup[0] = 1

    if lookup[n] != 0:
        return lookup[n]

    result = 0
    for i in range(n):
        if lookup[i] == 0:
            lookup[i] = cn2(i, lookup)
        if lookup[n - 1 - i] == 0:
            lookup[n - 1 - i] = cn2(n - 1 - i, lookup)
        result += lookup[i] * lookup[n - 1 - i]

    lookup[n] = result
    return result

@lru_cache(maxsize=None)
def cn3(n):
    if n == 0:
        return 1
    else:
        result = 0
        for i in range(n):
            result += cn3(i) * cn3(n - 1 - i)
        return result
print("Catalan numbers from C0 to C16:")

for i in range(17):
    print(f"C{i} = {cn(i)}")

print(timeit.timeit("cn(16)", setup="from __main__ import cn", number=5))
print(timeit.timeit("cn2(16)", setup="from __main__ import cn2", number=5))
print(timeit.timeit("cn3(16)", setup="from __main__ import cn3", number=5))